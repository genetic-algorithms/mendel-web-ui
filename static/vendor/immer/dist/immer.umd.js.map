{"version":3,"file":"immer.umd.js","sources":["../src/common.js","../src/proxy.js","../src/es5.js","../src/immer.js"],"sourcesContent":["export const PROXY_STATE =\n    typeof Symbol !== \"undefined\"\n        ? Symbol(\"immer-proxy-state\")\n        : \"__$immer_state\"\n\nexport const RETURNED_AND_MODIFIED_ERROR =\n    \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n\nfunction verifyMinified() {}\n\nconst inProduction =\n    (typeof process !== \"undefined\" && process.env.NODE_ENV === \"production\") ||\n    verifyMinified.name !== \"verifyMinified\"\n\nlet autoFreeze = !inProduction\nlet useProxies = typeof Proxy !== \"undefined\"\n\n/**\n * Automatically freezes any state trees generated by immer.\n * This protects against accidental modifications of the state tree outside of an immer function.\n * This comes with a performance impact, so it is recommended to disable this option in production.\n * It is by default enabled.\n *\n * @returns {void}\n */\nexport function setAutoFreeze(enableAutoFreeze) {\n    autoFreeze = enableAutoFreeze\n}\n\nexport function setUseProxies(value) {\n    useProxies = value\n}\n\nexport function getUseProxies() {\n    return useProxies\n}\n\nexport function isProxy(value) {\n    return !!value && !!value[PROXY_STATE]\n}\n\nexport function isProxyable(value) {\n    if (!value) return false\n    if (typeof value !== \"object\") return false\n    if (Array.isArray(value)) return true\n    const proto = Object.getPrototypeOf(value)\n    return proto === null || proto === Object.prototype\n}\n\nexport function freeze(value) {\n    if (autoFreeze) {\n        Object.freeze(value)\n    }\n    return value\n}\n\nconst assign =\n    Object.assign ||\n    function assign(target, value) {\n        for (let key in value) {\n            if (has(value, key)) {\n                target[key] = value[key]\n            }\n        }\n        return target\n    }\n\nexport function shallowCopy(value) {\n    if (Array.isArray(value)) return value.slice()\n    const target = value.__proto__ === undefined ? Object.create(null) : {}\n    return assign(target, value)\n}\n\nexport function each(value, cb) {\n    if (Array.isArray(value)) {\n        for (let i = 0; i < value.length; i++) cb(i, value[i])\n    } else {\n        for (let key in value) cb(key, value[key])\n    }\n}\n\nexport function has(thing, prop) {\n    return Object.prototype.hasOwnProperty.call(thing, prop)\n}\n\n// given a base object, returns it if unmodified, or return the changed cloned if modified\nexport function finalize(base) {\n    if (isProxy(base)) {\n        const state = base[PROXY_STATE]\n        if (state.modified === true) {\n            if (state.finalized === true) return state.copy\n            state.finalized = true\n            return finalizeObject(\n                useProxies ? state.copy : (state.copy = shallowCopy(base)),\n                state\n            )\n        } else {\n            return state.base\n        }\n    }\n    finalizeNonProxiedObject(base)\n    return base\n}\n\nfunction finalizeObject(copy, state) {\n    const base = state.base\n    each(copy, (prop, value) => {\n        if (value !== base[prop]) copy[prop] = finalize(value)\n    })\n    return freeze(copy)\n}\n\nfunction finalizeNonProxiedObject(parent) {\n    // If finalize is called on an object that was not a proxy, it means that it is an object that was not there in the original\n    // tree and it could contain proxies at arbitrarily places. Let's find and finalize them as well\n    if (!isProxyable(parent)) return\n    if (Object.isFrozen(parent)) return\n    each(parent, (i, child) => {\n        if (isProxy(child)) {\n            parent[i] = finalize(child)\n        } else finalizeNonProxiedObject(child)\n    })\n    // always freeze completely new data\n    freeze(parent)\n}\n\nexport function verifyReturnValue(returnedValue, proxy, isProxyModified) {\n    if (returnedValue !== undefined && returnedValue !== proxy) {\n        // something was returned, and it wasn't the proxy itself\n        if (isProxyModified)\n            throw new Error(\n                \"An immer producer returned a new value *and* modified its draft. Either return a new value *or* modify the draft.\"\n            )\n    }\n}\n\nexport function is(x, y) {\n    // From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (x === y) {\n        return x !== 0 || 1 / x === 1 / y\n    } else {\n        return x !== x && y !== y\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    has,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    finalize,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each\n} from \"./common\"\n\nlet proxies = null\n\nconst objectTraps = {\n    get,\n    has(target, prop) {\n        return prop in source(target)\n    },\n    ownKeys(target) {\n        return Reflect.ownKeys(source(target))\n    },\n    set,\n    deleteProperty,\n    getOwnPropertyDescriptor,\n    defineProperty,\n    setPrototypeOf() {\n        throw new Error(\"Immer does not support `setPrototypeOf()`.\")\n    }\n}\n\nconst arrayTraps = {}\neach(objectTraps, (key, fn) => {\n    arrayTraps[key] = function() {\n        arguments[0] = arguments[0][0]\n        return fn.apply(this, arguments)\n    }\n})\n\nfunction createState(parent, base) {\n    return {\n        modified: false,\n        finalized: false,\n        parent,\n        base,\n        copy: undefined,\n        proxies: {}\n    }\n}\n\nfunction source(state) {\n    return state.modified === true ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    if (prop === PROXY_STATE) return state\n    if (state.modified) {\n        const value = state.copy[prop]\n        if (value === state.base[prop] && isProxyable(value))\n            // only create proxy if it is not yet a proxy, and not a new object\n            // (new objects don't need proxying, they will be processed in finalize anyway)\n            return (state.copy[prop] = createProxy(state, value))\n        return value\n    } else {\n        if (has(state.proxies, prop)) return state.proxies[prop]\n        const value = state.base[prop]\n        if (!isProxy(value) && isProxyable(value))\n            return (state.proxies[prop] = createProxy(state, value))\n        return value\n    }\n}\n\nfunction set(state, prop, value) {\n    if (!state.modified) {\n        if (\n            (prop in state.base && is(state.base[prop], value)) ||\n            (has(state.proxies, prop) && state.proxies[prop] === value)\n        )\n            return true\n        markChanged(state)\n    }\n    state.copy[prop] = value\n    return true\n}\n\nfunction deleteProperty(state, prop) {\n    markChanged(state)\n    delete state.copy[prop]\n    return true\n}\n\nfunction getOwnPropertyDescriptor(state, prop) {\n    const owner = state.modified\n        ? state.copy\n        : has(state.proxies, prop) ? state.proxies : state.base\n    const descriptor = Reflect.getOwnPropertyDescriptor(owner, prop)\n    if (descriptor && !(Array.isArray(owner) && prop === \"length\"))\n        descriptor.configurable = true\n    return descriptor\n}\n\nfunction defineProperty() {\n    throw new Error(\n        \"Immer does not support defining properties on draft objects.\"\n    )\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        state.copy = shallowCopy(state.base)\n        // copy the proxies over the base-copy\n        Object.assign(state.copy, state.proxies) // yup that works for arrays as well\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parentState, base) {\n    if (isProxy(base)) throw new Error(\"Immer bug. Plz report.\")\n    const state = createState(parentState, base)\n    const proxy = Array.isArray(base)\n        ? Proxy.revocable([state], arrayTraps)\n        : Proxy.revocable(state, objectTraps)\n    proxies.push(proxy)\n    return proxy.proxy\n}\n\nexport function produceProxy(baseState, producer) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const previousProxies = proxies\n    proxies = []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n\n            // See #117\n            // Should we just throw when returning a proxy which is not the root, but a subset of the original state?\n            // Looks like a wrongly modeled reducer\n            result = finalize(returnValue)\n        } else {\n            result = finalize(rootProxy)\n        }\n        // revoke all proxies\n        each(proxies, (_, p) => p.revoke())\n        return result\n    } finally {\n        proxies = previousProxies\n    }\n}\n","\"use strict\"\n// @ts-check\n\nimport {\n    is,\n    isProxyable,\n    isProxy,\n    PROXY_STATE,\n    shallowCopy,\n    RETURNED_AND_MODIFIED_ERROR,\n    each,\n    finalize\n} from \"./common\"\n\nconst descriptors = {}\nlet states = null\n\nfunction createState(parent, proxy, base) {\n    return {\n        modified: false,\n        hasCopy: false,\n        parent,\n        base,\n        proxy,\n        copy: undefined,\n        finished: false,\n        finalizing: false,\n        finalized: false\n    }\n}\n\nfunction source(state) {\n    return state.hasCopy ? state.copy : state.base\n}\n\nfunction get(state, prop) {\n    assertUnfinished(state)\n    const value = source(state)[prop]\n    if (!state.finalizing && value === state.base[prop] && isProxyable(value)) {\n        // only create a proxy if the value is proxyable, and the value was in the base state\n        // if it wasn't in the base state, the object is already modified and we will process it in finalize\n        prepareCopy(state)\n        return (state.copy[prop] = createProxy(state, value))\n    }\n    return value\n}\n\nfunction set(state, prop, value) {\n    assertUnfinished(state)\n    if (!state.modified) {\n        if (is(source(state)[prop], value)) return\n        markChanged(state)\n        prepareCopy(state)\n    }\n    state.copy[prop] = value\n}\n\nfunction markChanged(state) {\n    if (!state.modified) {\n        state.modified = true\n        if (state.parent) markChanged(state.parent)\n    }\n}\n\nfunction prepareCopy(state) {\n    if (state.hasCopy) return\n    state.hasCopy = true\n    state.copy = shallowCopy(state.base)\n}\n\n// creates a proxy for plain objects / arrays\nfunction createProxy(parent, base) {\n    const proxy = shallowCopy(base)\n    each(base, i => {\n        Object.defineProperty(proxy, \"\" + i, createPropertyProxy(\"\" + i))\n    })\n    const state = createState(parent, proxy, base)\n    createHiddenProperty(proxy, PROXY_STATE, state)\n    states.push(state)\n    return proxy\n}\n\nfunction createPropertyProxy(prop) {\n    return (\n        descriptors[prop] ||\n        (descriptors[prop] = {\n            configurable: true,\n            enumerable: true,\n            get() {\n                return get(this[PROXY_STATE], prop)\n            },\n            set(value) {\n                set(this[PROXY_STATE], prop, value)\n            }\n        })\n    )\n}\n\nfunction assertUnfinished(state) {\n    if (state.finished === true)\n        throw new Error(\n            \"Cannot use a proxy that has been revoked. Did you pass an object from inside an immer function to an async process? \" +\n                JSON.stringify(state.copy || state.base)\n        )\n}\n\n// this sounds very expensive, but actually it is not that expensive in practice\n// as it will only visit proxies, and only do key-based change detection for objects for\n// which it is not already know that they are changed (that is, only object for which no known key was changed)\nfunction markChanges() {\n    // intentionally we process the proxies in reverse order;\n    // ideally we start by processing leafs in the tree, because if a child has changed, we don't have to check the parent anymore\n    // reverse order of proxy creation approximates this\n    for (let i = states.length - 1; i >= 0; i--) {\n        const state = states[i]\n        if (state.modified === false) {\n            if (Array.isArray(state.base)) {\n                if (hasArrayChanges(state)) markChanged(state)\n            } else if (hasObjectChanges(state)) markChanged(state)\n        }\n    }\n}\n\nfunction hasObjectChanges(state) {\n    const baseKeys = Object.keys(state.base)\n    const keys = Object.keys(state.proxy)\n    return !shallowEqual(baseKeys, keys)\n}\n\nfunction hasArrayChanges(state) {\n    const {proxy} = state\n    if (proxy.length !== state.base.length) return true\n    // See #116\n    // If we first shorten the length, our array interceptors will be removed.\n    // If after that new items are added, result in the same original length,\n    // those last items will have no intercepting property.\n    // So if there is no own descriptor on the last position, we know that items were removed and added\n    // N.B.: splice, unshift, etc only shift values around, but not prop descriptors, so we only have to check\n    // the last one\n    const descriptor = Object.getOwnPropertyDescriptor(proxy, proxy.length - 1)\n    // descriptor can be null, but only for newly created sparse arrays, eg. new Array(10)\n    if (descriptor && !descriptor.get) return true\n    // For all other cases, we don't have to compare, as they would have been picked up by the index setters\n    return false\n}\n\nexport function produceEs5(baseState, producer) {\n    if (isProxy(baseState)) {\n        // See #100, don't nest producers\n        const returnValue = producer.call(baseState, baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n    const prevStates = states\n    states = []\n    try {\n        // create proxy for root\n        const rootProxy = createProxy(undefined, baseState)\n        // execute the thunk\n        const returnValue = producer.call(rootProxy, rootProxy)\n        // and finalize the modified proxy\n        each(states, (_, state) => {\n            state.finalizing = true\n        })\n        // find and mark all changes (for parts not done yet)\n        // TODO: store states by depth, to be able guarantee processing leaves first\n        markChanges()\n        let result\n        // check whether the draft was modified and/or a value was returned\n        if (returnValue !== undefined && returnValue !== rootProxy) {\n            // something was returned, and it wasn't the proxy itself\n            if (rootProxy[PROXY_STATE].modified)\n                throw new Error(RETURNED_AND_MODIFIED_ERROR)\n            result = finalize(returnValue)\n        } else result = finalize(rootProxy)\n        // make sure all proxies become unusable\n        each(states, (_, state) => {\n            state.finished = true\n        })\n        return result\n    } finally {\n        states = prevStates\n    }\n}\n\nfunction shallowEqual(objA, objB) {\n    //From: https://github.com/facebook/fbjs/blob/c69904a511b900266935168223063dd8772dfc40/packages/fbjs/src/core/shallowEqual.js\n    if (is(objA, objB)) return true\n    if (\n        typeof objA !== \"object\" ||\n        objA === null ||\n        typeof objB !== \"object\" ||\n        objB === null\n    ) {\n        return false\n    }\n    const keysA = Object.keys(objA)\n    const keysB = Object.keys(objB)\n    if (keysA.length !== keysB.length) return false\n    for (let i = 0; i < keysA.length; i++) {\n        if (\n            !hasOwnProperty.call(objB, keysA[i]) ||\n            !is(objA[keysA[i]], objB[keysA[i]])\n        ) {\n            return false\n        }\n    }\n    return true\n}\n\nfunction createHiddenProperty(target, prop, value) {\n    Object.defineProperty(target, prop, {\n        value: value,\n        enumerable: false,\n        writable: true\n    })\n}\n","export {setAutoFreeze, setUseProxies} from \"./common\"\n\nimport {isProxyable, getUseProxies} from \"./common\"\nimport {produceProxy} from \"./proxy\"\nimport {produceEs5} from \"./es5\"\n\n/**\n * produce takes a state, and runs a function against it.\n * That function can freely mutate the state, as it will create copies-on-write.\n * This means that the original state will stay unchanged, and once the function finishes, the modified state is returned\n *\n * @export\n * @param {any} baseState - the state to start with\n * @param {Function} producer - function that receives a proxy of the base state as first argument and which can be freely modified\n * @returns {any} a new state, or the base state if nothing was modified\n */\nexport default function produce(baseState, producer) {\n    // prettier-ignore\n    if (arguments.length !== 1 && arguments.length !== 2) throw new Error(\"produce expects 1 or 2 arguments, got \" + arguments.length)\n\n    // curried invocation\n    if (typeof baseState === \"function\") {\n        // prettier-ignore\n        if (typeof producer === \"function\") throw new Error(\"if first argument is a function (curried invocation), the second argument to produce cannot be a function\")\n\n        const initialState = producer\n        const recipe = baseState\n\n        return function() {\n            const args = arguments\n\n            const currentState =\n                args[0] === undefined && initialState !== undefined\n                    ? initialState\n                    : args[0]\n\n            return produce(currentState, draft => {\n                args[0] = draft // blegh!\n                return recipe.apply(draft, args)\n            })\n        }\n    }\n\n    // prettier-ignore\n    {\n        if (typeof producer !== \"function\") throw new Error(\"if first argument is not a function, the second argument to produce should be a function\")\n    }\n\n    // if state is a primitive, don't bother proxying at all\n    if (typeof baseState !== \"object\" || baseState === null) {\n        const returnValue = producer(baseState)\n        return returnValue === undefined ? baseState : returnValue\n    }\n\n    if (!isProxyable(baseState))\n        throw new Error(\n            `the first argument to an immer producer should be a primitive, plain object or array, got ${typeof baseState}: \"${baseState}\"`\n        )\n    return getUseProxies()\n        ? produceProxy(baseState, producer)\n        : produceEs5(baseState, producer)\n}\n"],"names":["PROXY_STATE","Symbol","RETURNED_AND_MODIFIED_ERROR","autoFreeze","process","env","NODE_ENV","name","useProxies","Proxy","isProxy","value","isProxyable","Array","isArray","proto","Object","getPrototypeOf","prototype","freeze","assign","target","key","has","shallowCopy","slice","undefined","__proto__","create","each","cb","i","length","thing","prop","hasOwnProperty","call","finalize","base","state","modified","finalized","copy","finalizeNonProxiedObject","parent","isFrozen","child","is","x","y","proxies","objectTraps","createProxy","source","Reflect","ownKeys","owner","descriptor","getOwnPropertyDescriptor","configurable","Error","arrayTraps","markChanged","parentState","proxy","revocable","push","fn","arguments","apply","this","descriptors","states","hasCopy","prepareCopy","defineProperty","finalizing","get","assertUnfinished","finished","JSON","stringify","hasArrayChanges","produceEs5","baseState","producer","returnValue","prevStates","rootProxy","_","baseKeys","keys","objA","objB","keysA","keysB","shallowEqual","result","produce","initialState","recipe","args","draft","previousProxies","p","revoke","produceProxy","enableAutoFreeze"],"mappings":"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"}